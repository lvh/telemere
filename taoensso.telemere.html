<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>taoensso.telemere documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Telemere</span> <span class="project-version">1.0.0-SNAPSHOT</span></span></a></h1><div id="langs"><div class="lang current">clj</div><div class="lang"><a href="index.cljs.html">cljs</a></div></div></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="taoensso.telemere.html"><div class="inner"><span>taoensso.telemere</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.telemere.html#var-*ctx*"><div class="inner"><span>*ctx*</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-*middleware*"><div class="inner"><span>*middleware*</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-add-handler.21"><div class="inner"><span>add-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-catch-.3Eerror.21"><div class="inner"><span>catch-&gt;error!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-chance"><div class="inner"><span>chance</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-check-interop"><div class="inner"><span>check-interop</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-default-ctx"><div class="inner"><span>default-ctx</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-error.21"><div class="inner"><span>error!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-event.21"><div class="inner"><span>event!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-format-error"><div class="inner"><span>format-error</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-format-instant"><div class="inner"><span>format-instant</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-get-env"><div class="inner"><span>get-env</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-get-filters"><div class="inner"><span>get-filters</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-get-handlers"><div class="inner"><span>get-handlers</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-get-min-level"><div class="inner"><span>get-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-help.3Afilters"><div class="inner"><span>help:filters</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-help.3Ahandlers"><div class="inner"><span>help:handlers</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-help.3Asignal-content"><div class="inner"><span>help:signal-content</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-help.3Asignal-handling"><div class="inner"><span>help:signal-handling</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-help.3Asignal-options"><div class="inner"><span>help:signal-options</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-hostname"><div class="inner"><span>hostname</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-level-aliases"><div class="inner"><span>level-aliases</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-log.21"><div class="inner"><span>log!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-msg-skip"><div class="inner"><span>msg-skip</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-msg-splice"><div class="inner"><span>msg-splice</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-newline"><div class="inner"><span>newline</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-rate-limiter"><div class="inner"><span>rate-limiter</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-remove-handler.21"><div class="inner"><span>remove-handler!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-ctx.21"><div class="inner"><span>set-ctx!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-id-filter.21"><div class="inner"><span>set-id-filter!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-kind-filter.21"><div class="inner"><span>set-kind-filter!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-middleware.21"><div class="inner"><span>set-middleware!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-min-level.21"><div class="inner"><span>set-min-level!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-ns-filter.21"><div class="inner"><span>set-ns-filter!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-set-var-root.21"><div class="inner"><span>set-var-root!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-signal.21"><div class="inner"><span>signal!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-spy.21"><div class="inner"><span>spy!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-streams-.3Ereset.21"><div class="inner"><span>streams-&gt;reset!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-streams-.3Etelemere.21"><div class="inner"><span>streams-&gt;telemere!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-thread-id"><div class="inner"><span>thread-id</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-thread-name"><div class="inner"><span>thread-name</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-tools-logging-.3Etelemere.21"><div class="inner"><span>tools-logging-&gt;telemere!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-trace.21"><div class="inner"><span>trace!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-uncaught-.3Eerror.21"><div class="inner"><span>uncaught-&gt;error!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-uncaught-.3Ehandler.21"><div class="inner"><span>uncaught-&gt;handler!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-update-var-root.21"><div class="inner"><span>update-var-root!</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-ctx"><div class="inner"><span>with-ctx</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-ctx.2B"><div class="inner"><span>with-ctx+</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-err-.3Etelemere"><div class="inner"><span>with-err-&gt;telemere</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-handler"><div class="inner"><span>with-handler</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-handler.2B"><div class="inner"><span>with-handler+</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-id-filter"><div class="inner"><span>with-id-filter</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-kind-filter"><div class="inner"><span>with-kind-filter</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-middleware"><div class="inner"><span>with-middleware</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-min-level"><div class="inner"><span>with-min-level</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-ns-filter"><div class="inner"><span>with-ns-filter</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-out-.3Etelemere"><div class="inner"><span>with-out-&gt;telemere</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-signal"><div class="inner"><span>with-signal</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-signals"><div class="inner"><span>with-signals</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-with-streams-.3Etelemere"><div class="inner"><span>with-streams-&gt;telemere</span></div></a></li><li class="depth-1"><a href="taoensso.telemere.html#var-without-filters"><div class="inner"><span>without-filters</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.telemere</h1><div class="doc"><pre class="plaintext">Structured telemetry for Clojure/Script applications.

See the GitHub page (esp. Wiki) for info on motivation and design:
  &lt;<a href="https://www.taoensso.com/telemere">https://www.taoensso.com/telemere</a>&gt;</pre></div><div class="public anchor" id="var-*ctx*"><h3>*ctx*</h3><h4 class="dynamic">dynamic</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-*ctx*">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">Dynamic context: arbitrary user-level state attached as `:ctx` to all signals.
Value may be any type, but is usually nil or a map.

Re/bind dynamic     value using `with-ctx`, `with-ctx+`, or `binding`.
Modify  root (base) value using `set-ctx!`.
Default root (base) value is    `default-ctx`.

Note that as with all dynamic Clojure vars, "binding conveyance" applies
when using futures, agents, etc.

Tips:
  - Value may be (or may contain) an atom if you want mutable semantics
  - Value may be of form {&lt;scope-id&gt; &lt;data&gt;} for custom scoping, etc.</pre></div></div><div class="public anchor" id="var-*middleware*"><h3>*middleware*</h3><h4 class="dynamic">dynamic</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-*middleware*">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">Optional vector of unary middleware fns to apply (sequentially/left-to-right)
to each signal before passing it to handlers. If any middleware fn returns nil,
aborts immediately without calling handlers.

Useful for transforming each signal before handling.

Re/bind dynamic     value using `with-middleware`, `binding`.
Modify  root (base) value using `set-middleware!`.</pre></div></div><div class="public anchor" id="var-add-handler.21"><h3>add-handler!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-add-handler.21">cljs</a></h4><div class="usage"><code>(add-handler! handler-id handler-fn)</code><code>(add-handler! handler-id handler-fn dispatch-opts)</code></div><div class="doc"><pre class="plaintext">Registers given signal handler and returns
{&lt;handler-id&gt; {:keys [dispatch-opts handler-fn]}} for all signal handlers
now registered.

`handler-fn` should be a fn of 1-2 arities:

  ([handler-arg]) =&gt; Handle the given argument (e.g. write to disk/db, etc.)
  ([]) =&gt; Optional arity, called exactly once on system shutdown.
          Provides an opportunity for handler to close/release
          any resources that it may have opened/acquired.

See the relevant docstring/s for `handler-arg` details.

Handler ideas:

  Save to a db, `tap&gt;`, log, `put!` to an appropriate `core.async`
  channel, filter, aggregate, use for a realtime analytics dashboard,
  examine for outliers or unexpected data, etc.

Dispatch options include:

  `async` (Clj only)
     Options for running handler asynchronously via `taoensso.encore/runner`,
     {:keys [mode buffer-size n-threads daemon-threads? ...]}

     Supports `:blocking`, `:dropping`, and `:sliding` back pressure modes.
     NB handling order may be non-sequential when `n-threads` &gt; 1.

  `priority`
    Optional handler priority ∈ℤ (default 100). Handlers will be called in
    descending priority order.

  `sample-rate`
    Optional sample rate ∈ℝ[0,1], or (fn dyamic-sample-rate []) =&gt; ℝ[0,1].
    When present, handle only this (random) proportion of args:
      1.0 =&gt; handle every arg (same as `nil` rate, default)
      0.0 =&gt; noop   every arg
      0.5 =&gt; handle random 50% of args

  `ns-filter`   - Namespace filter as in `set-ns-filter!`
  `kind-filter` - Kind      filter as in `set-kind-filter!` (when relevant)
  `id-filter`   - Id        filter as in `set-id-filter!`   (when relevant)
  `min-level`   - Minimum   level  as in `set-min-level!`

  `when-fn`
    Optional nullary (fn allow? []) that must return truthy for handler to be
    called. When present, called *after* sampling and other filters, but before
    rate limiting.

  `rate-limit`
    Optional rate limit spec as provided to `taoensso.encore/rate-limiter`,
    {&lt;limit-id&gt; [&lt;n-max-calls&gt; &lt;msecs-window&gt;]}.

    Examples:
      {"1/sec"  [1   1000]} =&gt; Max 1  call  per 1000 msecs
      {"1/sec"  [1   1000]
       "10/min" [10 60000]} =&gt; Max 1  call  per 1000 msecs,
                               and 10 calls per 60   secs

  `middleware`
    Optional vector of unary middleware fns to apply (left-to-right/sequentially)
    to `handler-arg` before passing to `handler-fn`. If any middleware fn returns
    nil, aborts immediately without calling `handler-fn`.

    Useful for transforming `handler-arg` before handling.

  `error-fn` - (fn [{:keys [handler-id handler-arg error]}]) to call on handler error.
  `backp-fn` - (fn [{:keys [handler-id                  ]}]) to call on handler back pressure.

Flow sequence:

  1. Per call (n=1)
    a. Sampling
    b. Filtering (kind, namespace, id, level, when-form)
    c. Rate limiting
    d. Middleware

  2. Per handler (n&gt;=0)
    a. Sampling
    b. Filtering (kind, namespace, id, level, when-fn)
    c. Rate limiting
    d. Middleware
    e. Hander fn

  Note: call filters should generally be at least as permissive as handler filters,
  otherwise calls will be suppressed before reaching handlers.</pre></div></div><div class="public anchor" id="var-catch-.3Eerror.21"><h3>catch-&gt;error!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(catch-&gt;error! form)</code><code>(catch-&gt;error! id form)</code><code>(catch-&gt;error! {:as opts, :keys [rethrow? catch-val elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error &amp; user-opts]} form)</code></div><div class="doc"><pre class="plaintext">Unconditionally executes given form and-
  If form succeeds: return the form's result.
  If form   throws:
    Call `error!` with the thrown error and the given signal options [1],
    then return (:catch-val opts) if it exists, or rethrow the error.

API: [form] [id-or-opts form] =&gt; form's result (value/throw) (unconditional), or (:catch-val opts)
Default  kind: `:error`
Default level: `:error`

Examples:

  (catch-&gt;error! (/ 1 0)) ; %&gt; {:kind :error, :level :error, :error &lt;caught&gt; ...}
  (catch-&gt;error! {:id ::my-id, :catch-val "threw"} (/ 1 0)) ; %&gt; {... :id ::my-id ...}
  (catch-&gt;error!
    {:let  [x "x"] ; Available to `:data` and `:msg`
     :data {:x x}
     :msg_ ["My msg:" x]}
     (/ 1 0)) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (catch-&gt;error! ...)).
  - Supports the same options as other signals [1].

  - Useful for recording errors in forms, futures, callbacks, etc.

See also `error!`.

[1] See `help:signal-options` docstring</pre></div></div><div class="public anchor" id="var-chance"><h3>chance</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-chance">cljs</a></h4><div class="usage"><code>(chance prob)</code></div><div class="doc"><pre class="plaintext">Returns true with given probability ∈ ℝ[0,1].
</pre></div></div><div class="public anchor" id="var-check-interop"><h3>check-interop</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-check-interop">cljs</a></h4><div class="usage"><code>(check-interop)</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change.
Runs Telemere's registered interop checks and returns
{&lt;interop-id&gt; {:keys [sending-&gt;telemere? telemere-receiving? ...]}}.

Useful for tests/debugging.</pre></div></div><div class="public anchor" id="var-default-ctx"><h3>default-ctx</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-default-ctx">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">Advanced feature. Default root (base) value of `*ctx*` var, controlled by:
  (get-env {:as :edn} :taoensso.telemere/default-ctx&lt;.platform&gt;&lt;.edn&gt;)

See `get-env` for details.</pre></div></div><div class="public anchor" id="var-error.21"><h3>error!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(error! error)</code><code>(error! id error)</code><code>(error! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error &amp; user-opts]} error)</code></div><div class="doc"><pre class="plaintext">"Error" signal call, focused on error + id.

API: [error] [id-or-opts error] =&gt; given error (unconditional)
Default  kind: `:error`
Default level: `:error`

Examples:

  (throw (error!         (ex-info "MyEx" {}))) ; %&gt; {:kind :error, :level :error, :error &lt;MyEx&gt; ...}
  (throw (error! ::my-id (ex-info "MyEx" {}))) ; %&gt; {... :id ::my-id ...}
  (throw
    (error!
      {:let  [x "x"] ; Available to `:data` and `:msg`
       :data {:x x}
       :msg  ["My message:" x]}

      (ex-info "MyEx" {}))) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (error! ...)).
  - Supports the same options as other signals [3].

  - `error` arg is a platform error (`java.lang.Throwable` or `js/Error`).
  - Can conveniently be wrapped by `throw`: (throw (error! ...)).

[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-event.21"><h3>event!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(event! id)</code><code>(event! id level)</code><code>(event! id {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error &amp; user-opts]})</code></div><div class="doc"><pre class="plaintext">"Event" signal call, focused on id + level.

API: [id] [id level-or-opts] =&gt; true iff signal call was allowed
Default  kind: `:event`
Default level: `:info`

When conditions are met [1], creates a Telemere signal [2] and dispatches it to
registered handlers for processing (writing to console/disk/db, etc.).

Examples:

  (event! ::my-id)       ; %&gt; {:kind :event, :level :info, :id ::my-id ...}
  (event! ::my-id :warn) ; %&gt; {...           :level :warn ...}
  (event! ::my-id
    {:let  [x "x"] ; Available to `:data` and `:msg`
     :data {:x x}
     :msg  ["My msg:" x]}) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (error! ...)).
  - Supports the same options as other signals [3].

  - A good general-purpose signal, prefer to `log!` by default, since it
    better encourages structured data over unstructured messages.

  - Has a different 2-arity arg order to all other signals!
    Mnemonic: the arg that's typically larger is *always* in the rightmost
    position, and for `event!` that's the `level-or-opts` arg.

----------------------------------------
[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-format-error"><h3>format-error</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-format-error">cljs</a></h4><div class="usage"><code>(format-error error)</code><code>(format-error {:keys [use-fonts? sort-stacktrace-by fonts], :or {use-fonts? :auto, sort-stacktrace-by :chronological, fonts clj-commons.format.exceptions/default-fonts}} error)</code></div><div class="doc"><pre class="plaintext">TODO Docstring
</pre></div></div><div class="public anchor" id="var-format-instant"><h3>format-instant</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-format-instant">cljs</a></h4><div class="usage"><code>(format-instant instant)</code><code>(format-instant {:keys [formatter], :or {formatter java.time.format.DateTimeFormatter/ISO_INSTANT}} instant)</code></div><div class="doc"><pre class="plaintext">TODO Docstring
</pre></div></div><div class="public anchor" id="var-get-env"><h3>get-env</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="added">added in Encore v3.75.0 (2024-01-29)</h4><div class="usage"><code>(get-env {:keys [as default return]} spec)</code><code>(get-env {:keys [as default return spec], :or {as :str, return :value}})</code></div><div class="doc"><pre class="plaintext">Cross-platform util for embedding flexible environmental config during
macro expansion. Used by other Taoensso libraries.

Given a const kw/string id or vector of desc-priority alternative ids,
parse and return the first of the following that exists:
  - JVM         property value   for id ("prop")
  - Environment variable value   for id ("env")
  - Classpath   resource content for id ("res")

Ids may include optional segment in `&lt;&gt;` tag (e.g. `&lt;.edn&gt;`).
Ids may include `&lt;.?platform.?&gt;` tag for auto replacement, useful
for supporting platform-specific config.

Search order: desc by combined [alt-index platform(y/n) optional(y/n)].

(get-env {:as :edn} [:my-app/alt1&lt;.platform&gt;&lt;.edn&gt; :my-app/alt2])
will parse and return the first of the following that exists:

  1. Alt1 +platform +optional (content type)
    1a. `my-app.alt1.clj.edn` JVM         property value
    1b. `MY_APP_ALT1_CLJ_EDN` environment variable value
    1c. `my-app.alt1.clj.edn` classpath   resource content

  2. Alt1 +platform -optional (content type)
    2a. `my-app.alt1.clj`     JVM         property value
    2b. `MY_APP_ALT1_CLJ`     environment variable value
    2c. `my-app.alt1.clj`     classpath   resource content

  3. Alt1 -platform +optional (content type)
    3a. `my-app.alt1.edn`     JVM         property value
    3b. `MY_APP_ALT1_EDN`     environment variable value
    3c. `my-app.alt1.edn`     classpath   resource content

  4. Alt1 -platform -optional (content type)
    4a. `my-app.alt1`         JVM         property value
    4b. `MY_APP_ALT1`         environment variable value
    4c. `my-app.alt1`         classpath   resource content

  5. Alt2
    5a. `my-app.alt2`         JVM         property value
    5b. `MY_APP_ALT2`         environment variable value
    5c. `my-app.alt2`         classpath   resource content

Options:
  `:as`      - Parse found value as given type ∈ #{:str :bool :edn} (default :str).
  `:default` - Fallback to return if no value found during search (default nil).
  `:return`  - Return type ∈ #{:value :map :debug} (default :value).
               TIP: Use `:debug` to inspect/verify search behaviour!

Result must be something that can be safely embedded in code during
macro-expansion. Symbols in edn will be evaluated during expansion.</pre></div></div><div class="public anchor" id="var-get-filters"><h3>get-filters</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-get-filters">cljs</a></h4><div class="usage"><code>(get-filters)</code></div><div class="doc"><pre class="plaintext">Returns current ?{:keys [compile-time runtime]} filter config.
</pre></div></div><div class="public anchor" id="var-get-handlers"><h3>get-handlers</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-get-handlers">cljs</a></h4><div class="usage"><code>(get-handlers)</code></div><div class="doc"><pre class="plaintext">Returns ?{&lt;handler-id&gt; {:keys [dispatch-opts handler-fn]}} for all
registered signal handlers.</pre></div></div><div class="public anchor" id="var-get-min-level"><h3>get-min-level</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-get-min-level">cljs</a></h4><div class="usage"><code>(get-min-level)</code><code>(get-min-level kind)</code><code>(get-min-level kind ns)</code></div><div class="doc"><pre class="plaintext">Returns current ?{:keys [compile-time runtime]} minimum levels.
</pre></div></div><div class="public anchor" id="var-help.3Afilters"><h3>help:filters</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-help.3Afilters">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">Your filter config determines which signal calls will be allowed.

Filtering can occur at compile-time (=&gt; elision), or runtime.
Both compile-time and runtime config can be specified via:

  1. System values (JVM properties, environment variables, or
     classpath resources). See library docs for details.

  2. The filter API consting of the following:

    `set-ns-filter!`,     `with-ns-filter`      - for filtering calls by namespace
    `set-minimum-level!`, `with-minimum-level!` - for filtering calls by signal level
    `set-id-filter!`,     `with-id-filter`      - for filtering calls by signal id   (when relevant)
    `set-kind-filter!`,   `with-kind-filter`    - for filtering calls by signal kind (when relevant)

    See the relevant docstrings for details.

Additional filtering can also be applied on a per-handler basis, see
`add-handler!` for details.

See also:

  `get-filters`     - to see current filter config
  `get-min-level`   - to see current minimum level
  `without-filters` - to disable all runtime filtering

If anything is unclear, please ping me (@ptaoussanis) so that I can
improve these docs!</pre></div></div><div class="public anchor" id="var-help.3Ahandlers"><h3>help:handlers</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-help.3Ahandlers">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">The handler API consists of the following:

  `get-handlers`    - Returns info on currently registered handlers
  `add-handler!`    - Used to   register handlers
  `remove-handler!` - Used to unregister handlers

See the relevant docstrings for details.

If anything is unclear, please ping me (@ptaoussanis) so that I can
improve these docs!</pre></div></div><div class="public anchor" id="var-help.3Asignal-content"><h3>help:signal-content</h3><h4 class="lang current">clj</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Signals are initially maps with {:keys [instant id ns level data msg_ ...]},
though they can be modified by call and/or handler middleware.

Default keys:

`:schema-version` - Int version of signal schema (current: 1)

`:instant` - Platform instant [1] when signal was created
`:level`   - Signal level ∈ #{&lt;int&gt; :trace :debug :info :warn :error :fatal :report ...}
`:kind`    - Signal ?kind ∈ #{nil :event :error :log :trace :spy &lt;user-val&gt; ...}
`:id`      - ?id of signal call     (common to all signals created by signal call, contrast with `:uid`)
`:uid`     - ?id of signal instance (unique to each signal created by signal call, contrast with `:id`)

`:data`  - Arb user-level data     ?val (usu. a map) given to signal call
`:msg`   - Arb user-level message  ?str              given to signal call
`:error` - Arb user-level platform ?error [2]        given to signal call

`:run-form`     - Unevaluated ?form given to signal macro as `:run`
`:run-value`    - Successful return ?val of  `:run` ?form
`:end-instant`  - Platform ?instant [1] when `:run` ?form completed
`:runtime-nsecs`- ?int nanosecs runtime of   `:run` ?form

`:ctx`      - ?val of `*ctx*` (arb user-level state) when signal was created
`:parent`   - ?{:keys [id uid]} of parent signal, present in nested signals when tracing
`:location` - ?{:keys [ns file line column]} signal call location
`:ns`       - ?str namespace of signal call, same as (:ns     location)
`:file`     - ?str filename  of signal call, same as (:file   location)
`:line`     - ?int line      of signal call, same as (:line   location)
`:column`   - ?int column    of signal call, same as (:column location)

`:sample-rate` - ?rate ∈ℝ[0,1] for combined call AND handler sampling (0.75 =&gt; allow 75% of signals, nil =&gt; allow all)

If anything is unclear, please ping me (@ptaoussanis) so that I can improve these docs!

[1] Clj: `java.time.Instant`,    Cljs: `js/Date`
[2] Clj: `java.lang.Throwable`,  Cljs: `js/Error`</pre></div></div><div class="public anchor" id="var-help.3Asignal-handling"><h3>help:signal-handling</h3><h4 class="lang current">clj</h4><div class="usage"></div><div class="doc"><pre class="plaintext">A signal will be provided to a handler iff ALL of the following are true:

  1. Signal call is allowed by compile-time filters
  2. Signal call is allowed by runtime      filters
  3. Handler     is allowed by runtime      filters

  4. Signal call middleware does not suppress the signal (return nil)
  5. Handler     middleware does not suppress the signal (return nil)

For more info:

  - On call    filters, see: `help:filters`  docstring
  - On handler filters, see: `help:handlers` docstring
  - On signal flow,     see: Ref. &lt;<a href="https://tinyurl.com/telemere-signal-flowchart">https://tinyurl.com/telemere-signal-flowchart</a>&gt;

If anything is unclear, please ping me (@ptaoussanis) so that I can
improve these docs!</pre></div></div><div class="public anchor" id="var-help.3Asignal-options"><h3>help:signal-options</h3><h4 class="lang current">clj</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Signal options (shared by `signal!`, `event!`, ...):

`:instant` - Platform instant [1] when signal was created, ∈ #{nil :auto &lt;user-val&gt;}
`:level`   - Signal level ∈ #{&lt;int&gt; :trace :debug :info :warn :error :fatal :report ...}
`:kind`    - Signal ?kind ∈ #{nil :event :error :log :trace :spy &lt;user-val&gt; ...}
`:id`      - ?id of signal call     (common to all signals created by signal call, contrast with `:uid`)
`:uid`     - ?id of signal instance (unique to each signal created by signal call, contrast with `:id`)

`:data`  - Arb user-level ?data    to incl. in signal: usu. a map
`:msg`   - Arb user-level ?message to incl. in signal: str or vec of strs to join (with `\space`)
`:error` - Arb user-level ?error   to incl. in signal: platform error [2]

`:run` - ?form    to execute UNCONDITIONALLY; will incl. `:run-value` in signal
`:do`  - ?form    to execute   conditionally (iff signal allowed), before establishing `:let` ?binding
`:let` - ?binding to establish conditionally (iff signal allowed), BEFORE evaluating `:data` and `:msg` (useful!)

`:ctx`      - Custom ?val to override auto (dynamic `*ctx*`) in signal
`:parent`   - Custom ?{:keys [id uid]} to override auto (dynamic) parent signal info in signal
`:location` - Custom ?{:keys [ns line column file]} to override auto signal call location

`:elidable?`   - Should signal call be subject to compile-time elision? (Default: true)
`:sample-rate` - ?rate ∈ℝ[0,1] for call sampling (0.75 =&gt; allow 75% of signals, nil =&gt; allow all)
`:when`        - Arb ?form; when present, form must return truthy to allow signal
`:rate-limit`  - ?spec as given to `telemere/rate-limiter`, see its docstring for details
`:middleware`  - ?[(fn [signal])=&gt;modified-signal ...] call middleware
`:trace?`      - Should tracing be enabled for `:run` form?

&lt;user-opts&gt;    - Arb user-level ?kvs to incl. in signal

If anything is unclear, please ping me (@ptaoussanis) so that I can improve these docs!

[1] Clj: `java.time.Instant`,    Cljs: `js/Date`
[2] Clj: `java.lang.Throwable`,  Cljs: `js/Error`</pre></div></div><div class="public anchor" id="var-hostname"><h3>hostname</h3><h4 class="lang current">clj</h4><div class="usage"><code>(hostname)</code><code>(hostname timeout-msecs timeout-val)</code></div><div class="doc"><pre class="plaintext">Returns local cached hostname string, or `timeout-val` (default "UnknownHost").
</pre></div></div><div class="public anchor" id="var-level-aliases"><h3>level-aliases</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-level-aliases">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">Map of {&lt;level-keyword&gt; &lt;level-integer&gt;} aliases.
</pre></div></div><div class="public anchor" id="var-log.21"><h3>log!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(log! msg)</code><code>(log! level msg)</code><code>(log! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error &amp; user-opts]} msg)</code></div><div class="doc"><pre class="plaintext">"Log" signal call, focused on message + level.

API: [msg] [level-or-opts msg] =&gt; true iff signal call was allowed.
Default  kind: `:log`
Default level: `:info`

When conditions are met [1], creates a Telemere signal [2] and dispatches it to
registered handlers for processing (writing to console/disk/db, etc.).

Examples:

  (log! "My msg")       ; %&gt; {:kind :log, :level :info, :id ::my-id ...}
  (log! :warn "My msg") ; %&gt; {...         :level :warn ...}
  (log!
    {:let  [x "x"] ; Available to `:data` and `:msg`
     :data {:x x}}

    ["My msg:" x]) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (log! ...)).
  - Supports the same options as other signals [3].

  - Prefer `event!` to `log!` by default, since it better encourages structured
    data over unstructured messages.

  - `msg` arg may be a string, or vector of strings to join with `\space`.
  - See also `msg-splice`, `msg-skip` utils.

----------------------------------------
[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-msg-skip"><h3>msg-skip</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-msg-skip">cljs</a></h4><div class="usage"></div><div class="doc"><pre class="plaintext">For use within signal message vectors.
Special value that will be ignored (no-op) when creating message.
Useful for conditionally skipping parts of message content, etc.:

  (signal! {:msg ["Hello" (if &lt;cond&gt; &lt;then&gt; msg-skip) "world"] &lt;...&gt;}) or
  (log!          ["Hello" (if &lt;cond&gt; &lt;then&gt; msg-skip) "world"]), etc.

    %&gt; {:msg_ "Hello world" &lt;...&gt;}</pre></div></div><div class="public anchor" id="var-msg-splice"><h3>msg-splice</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-msg-splice">cljs</a></h4><div class="usage"><code>(msg-splice args)</code></div><div class="doc"><pre class="plaintext">For use within signal message vectors.
Wraps given arguments so that they're spliced when creating message.
Useful for conditionally splicing in extra message content, etc.:

  (signal! {:msg [(when &lt;cond&gt; (msg-splice ["Username:" "Steve"])) &lt;...&gt;]}) or
  (log!          [(when &lt;cond&gt; (msg-splice ["Username:" "Steve"]))])

    %&gt; {:msg_ "Username: Steve"}</pre></div></div><div class="public anchor" id="var-newline"><h3>newline</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-newline">cljs</a></h4><h4 class="added">added in Encore v3.68.0 (2023-09-25)</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Single system newline
</pre></div></div><div class="public anchor" id="var-rate-limiter"><h3>rate-limiter</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-rate-limiter">cljs</a></h4><div class="usage"><code>(rate-limiter spec)</code><code>(rate-limiter opts spec)</code></div><div class="doc"><pre class="plaintext">Takes a map spec of form {&lt;limit-id&gt; [&lt;n-max-reqs&gt; &lt;msecs-window&gt;]},
and returns a basic stateful (fn rate-limiter [req-id] [command req-id]).

Call fn with a single request id (e.g. username) by which to count/limit.
Will return:
  - nil when all limits pass for that id, or
  - [&lt;worst-limit-id&gt; &lt;worst-backoff-msecs&gt; {&lt;limit-id&gt; &lt;backoff-msecs&gt;}]
    when any limits fail for that id.

Or call fn with an additional command argument:
  `:rl/peek`  &lt;req-id&gt; - Check limits w/o incrementing count.
  `:rl/reset` &lt;req-id&gt; - Reset all limits for given req-id.

Example:

  (defonce my-rate-limiter
    (rate-limiter
      {"1  per sec" [1   1000]
       "10 per min" [10 60000]}))

  (defn send-message! [username msg-content]
    (if-let [fail (my-rate-limiter username)]
      (throw (ex-info "Sorry, rate limited!" {:fail fail}))
      &lt;send message&gt;))</pre></div></div><div class="public anchor" id="var-remove-handler.21"><h3>remove-handler!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-remove-handler.21">cljs</a></h4><div class="usage"><code>(remove-handler! handler-id)</code></div><div class="doc"><pre class="plaintext">Deregisters signal handler with given id, and returns
?{&lt;handler-id&gt; {:keys [dispatch-opts handler-fn]}} for all signal handlers
still registered.</pre></div></div><div class="public anchor" id="var-set-ctx.21"><h3>set-ctx!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(set-ctx! root-val)</code></div><div class="doc"><pre class="plaintext">Set `*ctx*` var's root (base) value. See `*ctx*` for details.
</pre></div></div><div class="public anchor" id="var-set-id-filter.21"><h3>set-id-filter!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-set-id-filter.21">cljs</a></h4><div class="usage"><code>(set-id-filter! id-filter)</code></div><div class="doc"><pre class="plaintext">Sets signal call id filter based on given `id-filter` spec.
`id-filter` may be:

  - A regex pattern of id/s to allow.
  - A str/kw/sym, in which "*"s act as wildcards.
  - A vector or set of regex patterns or strs/kws/syms.
  - {:allow &lt;spec&gt; :deny &lt;spec&gt;} with specs as above.</pre></div></div><div class="public anchor" id="var-set-kind-filter.21"><h3>set-kind-filter!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-set-kind-filter.21">cljs</a></h4><div class="usage"><code>(set-kind-filter! kind-filter)</code></div><div class="doc"><pre class="plaintext">Sets signal call kind filter based on given `kind-filter` spec.
`kind-filter` may be:

  - A regex pattern of kind/s to allow.
  - A str/kw/sym, in which "*"s act as wildcards.
  - A vector or set of regex patterns or strs/kws/syms.
  - {:allow &lt;spec&gt; :deny &lt;spec&gt;} with specs as above.</pre></div></div><div class="public anchor" id="var-set-middleware.21"><h3>set-middleware!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(set-middleware! root-val)</code></div><div class="doc"><pre class="plaintext">Set `*middleware*` var's root (base) value. See `*middleware*` for details.
</pre></div></div><div class="public anchor" id="var-set-min-level.21"><h3>set-min-level!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-set-min-level.21">cljs</a></h4><div class="usage"><code>(set-min-level! min-level)</code><code>(set-min-level! kind min-level)</code><code>(set-min-level! kind ns-filter min-level)</code></div><div class="doc"><pre class="plaintext">Sets minimum signal call level based on given `min-level` spec.
`min-level` may be:

  - An integer.
  - A level keyword (see `level-aliases` var for details).

If `ns-filter` is provided, then the given minimum level
will apply only for namespaces that match `ns-filter`.
See `set-ns-filter!` for details.

If non-nil `kind` is provided, then the given minimum level
will apply only for that signal kind.</pre></div></div><div class="public anchor" id="var-set-ns-filter.21"><h3>set-ns-filter!</h3><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-set-ns-filter.21">cljs</a></h4><div class="usage"><code>(set-ns-filter! ns-filter)</code></div><div class="doc"><pre class="plaintext">Sets signal call namespace filter based on given `ns-filter` spec.
`ns-filter` may be:

  - A regex pattern of namespace/s to allow.
  - A str/kw/sym, in which "*"s act as wildcards.
  - A vector or set of regex patterns or strs/kws/syms.
  - {:allow &lt;spec&gt; :deny &lt;spec&gt;} with specs as above.</pre></div></div><div class="public anchor" id="var-set-var-root.21"><h3>set-var-root!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="added">added in Encore v3.75.0 (2024-01-29)</h4><div class="usage"><code>(set-var-root! var-sym root-val)</code></div><div class="doc"><pre class="plaintext">Sets root binding (value) of the var identified by given symbol, and returns
the new value. Cross-platform. See also `update-var-root!`.</pre></div></div><div class="public anchor" id="var-signal.21"><h3>signal!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(signal! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error run &amp; user-opts]})</code></div><div class="doc"><pre class="plaintext">Low-level generic signal call.

API: [opts] =&gt; depends on options [3]
Default  kind: none (optional)
Default level: none (must be provided)

When conditions are met [1], creates a Telemere signal [2] and dispatches it to
registered handlers for processing (writing to console/disk/db, etc.).

If `:run` option is provided: returns value of given run form, or throws.
                   Otherwise: returns true iff call conditions were met.

Generic signals are fairly low-level and useful mostly for library authors or
advanced users writing their own wrapper macros. Regular users will typically
prefer one of the provided wrapper macros optimized for ease-of-use in
common cases.

These all use `signal!` underneath and offer the same options, but vary in
their defaults and the focus of their call APIs (args and return values):

  `event!` - (id      + opts/level) =&gt; true iff signal call was allowed
  `log!`   - (message + opts/level) =&gt; true iff signal call was allowed
  `error!` - (error   + opts/id)    =&gt; given error (unconditional)
  `trace!` - (form    + opts/id)    =&gt; form's result (value/throw) (unconditional)
  `spy!`   - (form    + opts/level) =&gt; form's result (value/throw) (unconditional)

Tips:

  - Test using `with-signals`: (with-signals (signal! ...)).
  - Supports the same options as other signals [3].

----------------------------------------
[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-spy.21"><h3>spy!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(spy! form)</code><code>(spy! id form)</code><code>(spy! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error run &amp; user-opts]} form)</code></div><div class="doc"><pre class="plaintext">"Spy" signal call, focused on form + level.

API: [form] [level-or-opts form] =&gt; form's result (value/throw) (unconditional)
Default kind:  `:spy`
Default level: `:info`

When conditions are met [1], creates a Telemere signal [2] and dispatches it to
registered handlers for processing (writing to console/disk/db, etc.).

Examples:

  (spy! (+ 1 2))         ; %&gt; {:kind :trace, :level :info, :run-form '(+ 1 2),
                         ;     :run-value 3, :parent {:keys [id uid]}
                         ;     :msg "(+ 1 2) =&gt; 3" ...}
  (spy! ::my-id (+ 1 2)) ; %&gt; {... :id ::my-id ...}
  (spy!
    {:let  [x "x"] ; Available to `:data` and `:msg`
     :data {:x x}}

    (+ 1 2)) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (spy! ...)).
  - Supports the same options as other signals [3].

  - Identical to `trace!`, but focused on form + level rather than form + id.

  - Useful for debugging/monitoring forms, and tracing (nested) execution flow.
  - Execution of `form` arg may trigger additional (nested) signals.
    Each signal's `:parent` key will indicate its immediate parent.

----------------------------------------
[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-streams-.3Ereset.21"><h3>streams-&gt;reset!</h3><h4 class="lang current">clj</h4><div class="usage"><code>(streams-&gt;reset!)</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change without notice!
Resets `System/out` and `System/err` to their original value (prior to any
`streams-&gt;telemere!` call).</pre></div></div><div class="public anchor" id="var-streams-.3Etelemere.21"><h3>streams-&gt;telemere!</h3><h4 class="lang current">clj</h4><div class="usage"><code>(streams-&gt;telemere!)</code><code>(streams-&gt;telemere! {:keys [out err], :or {out default-out-opts, err default-err-opts}})</code></div><div class="doc"><pre class="plaintext">Experimental, subject to change without notice!

When given `out`, sets JVM's `System/out` to flush to Telemere signals with those opts.
When given `err`, sets JVM's `System/err` to flush to Telemere signals with those opts.

Note that setting `System/out` won't necessarily affect Clojure's `*out*`,
and       setting `System/err` won't necessarily affect Clojure's `*err*`.

See also:
  `with-out-&gt;telemere`,
  `with-err-&gt;telemere`,
  `with-streams-&gt;telemere`.</pre></div></div><div class="public anchor" id="var-thread-id"><h3>thread-id</h3><h4 class="lang current">clj</h4><div class="usage"><code>(thread-id)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-thread-name"><h3>thread-name</h3><h4 class="lang current">clj</h4><div class="usage"><code>(thread-name)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-tools-logging-.3Etelemere.21"><h3>tools-logging-&gt;telemere!</h3><h4 class="lang current">clj</h4><div class="usage"><code>(tools-logging-&gt;telemere!)</code></div><div class="doc"><pre class="plaintext">Configures `clojure.tools.logging` to use Telemere as its logging implementation.
</pre></div></div><div class="public anchor" id="var-trace.21"><h3>trace!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(trace! form)</code><code>(trace! id form)</code><code>(trace! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error run &amp; user-opts]} form)</code></div><div class="doc"><pre class="plaintext">"Trace" signal call, focused on form + id.

API: [form] [id-or-opts form] =&gt; form's result (value/throw) (unconditional)
Default  kind: `:trace`
Default level: `:info` (intentionally NOT `:trace`!)

When conditions are met [1], creates a Telemere signal [2] and dispatches it to
registered handlers for processing (writing to console/disk/db, etc.).

Examples:

  (trace! (+ 1 2))         ; %&gt; {:kind :trace, :level :info, :run-form '(+ 1 2),
                           ;     :run-value 3, :parent {:keys [id uid]} ...
                           ;     :msg "(+ 1 2) =&gt; 3" ...}
  (trace! ::my-id (+ 1 2)) ; %&gt; {... :id ::my-id ...}
  (trace!
    {:let  [x "x"] ; Available to `:data` and `:msg`
     :data {:x x}}

    (+ 1 2)) ; %&gt; {... :data {x "x"}, :msg_ "My msg: x" ...}

Tips:

  - Test using `with-signals`: (with-signals (trace! ...)).
  - Supports the same options as other signals [3].

  - Identical to `spy!`, but focused on form + id rather than form + level.

  - Useful for debugging/monitoring forms, and tracing (nested) execution flow.
  - Execution of `form` arg may trigger additional (nested) signals.
    Each signal's `:parent` key will indicate its immediate parent.

  - Default level is `:info`, not `:trace`! The name "trace" in "trace signal"
    refers to the general action of tracing program flow rather than to the
    common logging level of the same name.

----------------------------------------
[1] See `help:signal-handling` docstring
[2] See `help:signal-content`  docstring
[3] See `help:signal-options`  docstring</pre></div></div><div class="public anchor" id="var-uncaught-.3Eerror.21"><h3>uncaught-&gt;error!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(uncaught-&gt;error!)</code><code>(uncaught-&gt;error! id)</code><code>(uncaught-&gt;error! {:as opts, :keys [elidable? location instant uid middleware sample-rate ns kind id level when rate-limit ctx parent trace? do let data msg error &amp; user-opts]})</code></div><div class="doc"><pre class="plaintext">Uses `uncaught-&gt;handler!` so that `error!` will be called for
uncaught JVM errors.

See `uncaught-&gt;handler!` and `error!` for details.</pre></div></div><div class="public anchor" id="var-uncaught-.3Ehandler.21"><h3>uncaught-&gt;handler!</h3><h4 class="lang current">clj</h4><div class="usage"><code>(uncaught-&gt;handler! handler)</code></div><div class="doc"><pre class="plaintext">Sets JVM's global `DefaultUncaughtExceptionHandler` to given
  (fn handler [`&lt;java.lang.Thread&gt;` `&lt;java.lang.Throwable&gt;`]).

See also `uncaught-&gt;error!`.</pre></div></div><div class="public anchor" id="var-update-var-root.21"><h3>update-var-root!</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="added">added in Encore v3.68.0 (2023-09-25)</h4><div class="usage"><code>(update-var-root! var-sym update-fn)</code></div><div class="doc"><pre class="plaintext">Updates root binding (value) of the var identified by given symbol, and returns
the new value:
  (update-var-root! my-var (fn [old-root-val] &lt;new-root-val&gt;)) =&gt; &lt;new-root-val&gt;

Similar to `alter-var-root` but cross-platform and takes a symbol rather than a var.
See also `set-var-root!`.</pre></div></div><div class="public anchor" id="var-with-ctx"><h3>with-ctx</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-ctx init-val form)</code></div><div class="doc"><pre class="plaintext">Evaluates given form with given `*ctx*` value. See `*ctx*` for details.
</pre></div></div><div class="public anchor" id="var-with-ctx.2B"><h3>with-ctx+</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-ctx+ update-map-or-fn form)</code></div><div class="doc"><pre class="plaintext">Evaluates given form with updated `*ctx*` value.

`update-map-or-fn` may be:
  - A map to merge with    current `*ctx*` value, or
  - A unary fn to apply to current `*ctx*` value

See `*ctx*` for details.</pre></div></div><div class="public anchor" id="var-with-err-.3Etelemere"><h3>with-err-&gt;telemere</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-err-&gt;telemere form)</code><code>(with-err-&gt;telemere opts form)</code></div><div class="doc"><pre class="plaintext">Executes form with `*err*` bound to flush to Telemere signals with given opts.
</pre></div></div><div class="public anchor" id="var-with-handler"><h3>with-handler</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-handler">cljs</a></h4><div class="usage"><code>(with-handler handler-id handler-fn dispatch-opts form)</code></div><div class="doc"><pre class="plaintext">Executes form with ONLY the given handler-fn registered.
Useful for tests/debugging. See also `with-handler+`.</pre></div></div><div class="public anchor" id="var-with-handler.2B"><h3>with-handler+</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-handler.2B">cljs</a></h4><div class="usage"><code>(with-handler+ handler-id handler-fn dispatch-opts form)</code></div><div class="doc"><pre class="plaintext">Executes form with the given handler-fn registered.
Useful for tests/debugging. See also `with-handler`.</pre></div></div><div class="public anchor" id="var-with-id-filter"><h3>with-id-filter</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-id-filter">cljs</a></h4><div class="usage"><code>(with-id-filter id-filter form)</code></div><div class="doc"><pre class="plaintext">Executes form with given signal call id filter in effect.
See `set-id-filter!` for details.</pre></div></div><div class="public anchor" id="var-with-kind-filter"><h3>with-kind-filter</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-kind-filter">cljs</a></h4><div class="usage"><code>(with-kind-filter kind-filter form)</code></div><div class="doc"><pre class="plaintext">Executes form with given signal call kind filter in effect.
See `set-kind-filter!` for details.</pre></div></div><div class="public anchor" id="var-with-middleware"><h3>with-middleware</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-middleware init-val form)</code></div><div class="doc"><pre class="plaintext">Evaluates given form with given `*middleware*` value.
See `*middleware*` for details.</pre></div></div><div class="public anchor" id="var-with-min-level"><h3>with-min-level</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-min-level">cljs</a></h4><div class="usage"><code>(with-min-level min-level form)</code><code>(with-min-level kind min-level form)</code><code>(with-min-level kind ns-filter min-level form)</code></div><div class="doc"><pre class="plaintext">Executes form with given minimum signal call level in effect.
See `set-min-level!` for details.</pre></div></div><div class="public anchor" id="var-with-ns-filter"><h3>with-ns-filter</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-with-ns-filter">cljs</a></h4><div class="usage"><code>(with-ns-filter ns-filter form)</code></div><div class="doc"><pre class="plaintext">Executes form with given signal call namespace filter in effect.
See `set-ns-filter!` for details.</pre></div></div><div class="public anchor" id="var-with-out-.3Etelemere"><h3>with-out-&gt;telemere</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-out-&gt;telemere form)</code><code>(with-out-&gt;telemere opts form)</code></div><div class="doc"><pre class="plaintext">Executes form with `*out*` bound to flush to Telemere signals with given opts.
</pre></div></div><div class="public anchor" id="var-with-signal"><h3>with-signal</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-signal form)</code></div><div class="doc"><pre class="plaintext">Experimental
Minimal version of `with-signals`.
Executes given form and returns the last signal triggered by it.
Useful for tests/debugging.

- Always allows registered handlers to receive signals as usual.
- Always traps form errors.
- Never forces `:msg_` key.

See also `with-signals` for more options.</pre></div></div><div class="public anchor" id="var-with-signals"><h3>with-signals</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-signals form)</code><code>(with-signals {:keys [handle? trap-errors? force-msg?], :or {handle? true}} form)</code></div><div class="doc"><pre class="plaintext">Experimental.
Executes given form and records any signals triggered by it.
Return value depends on given options. Useful for tests/debugging.

Options:

  `handle?`
    Should registered handlers receive signals triggered by form, as usual?
    Default: true.

  `trap-errors?`
    If  true: returns [[form-value form-error] signals], trapping any form error.
    If false: returns [ form-value             signals], throwing on  form error.
    Default: false.

  `force-msg?`
    Should delayed `:msg_` keys in signals be replaced with realized strings?
    Default: false.

See also `with-signal` for a simpler API.</pre></div></div><div class="public anchor" id="var-with-streams-.3Etelemere"><h3>with-streams-&gt;telemere</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><div class="usage"><code>(with-streams-&gt;telemere form)</code><code>(with-streams-&gt;telemere {:keys [out err], :or {out default-out-opts, err default-err-opts}} form)</code></div><div class="doc"><pre class="plaintext">Executes form with `*out*` and/or `*err*` bound to flush to Telemere signals
with given opts.</pre></div></div><div class="public anchor" id="var-without-filters"><h3>without-filters</h3><h4 class="type">macro</h4><h4 class="lang current">clj</h4><h4 class="lang"><a href="taoensso.telemere.cljs.html#var-without-filters">cljs</a></h4><div class="usage"><code>(without-filters form)</code></div><div class="doc"><pre class="plaintext">Executes form without any runtime filters.
</pre></div></div></div></body></html>